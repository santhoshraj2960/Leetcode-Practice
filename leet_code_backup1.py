

1 good thing: I go off schedule very rarely.I plan things very well.
Good planner: eg. Code jam. Leading a team of 6 and worked hard during the weekend so that the uncertainities surrounding how to get started
is not there when the team starts to work. Put in extra effort to make sure that the team does some work and feel good at the end of the
day that they have contributed to he project. Intentionally take up a task, work on it half way through and then assign it to someone
the next day so that they get exposure to the work.
One of the challenges in work:
Principal gaves us trades, advisers, all advisers, investment, firms data. They didnt tell us what we have to do with the data. Rather, they
asked us to come up with ideas using that data and do something with_it
i - 
  We have the trades data. Can we group the trades by location (say pin code) and figure out how many transactions happen in a day and the amount
   generated by those transactions?
We can then compare the number of transactions and the total amount in a particular locality to the max number of transactions and the maximum 
amount generated on a given day (which might be in a different locality) and give a score to each locality (or pincode). This might help the sales
 team to go after new advisers in those localities which have a higher score because these advisors will bring more value and business than the
  advisers who come from a locality which has a lower score.

Given the demographic information (no of males, females, per capita income, etc.) of a particular locality, based on the number of transactions 
that have happened in the past (say a time frame - last 3 months), our model will predict the number of transactions that might occur in a month 
and based on that the sales team can decide if they should go after advisers in that locality. 
Does this sound like a good business problem to solve?
Given a new zipcode, use an api to fetch the demographics of that zip code from backend and the model should predict the number of transactions 
and sum of amount involved in those transactions for the current month. Based on that the sales team can decide if they should target advisers in
 a particular locality (zipcode)

Time when deadline not met:
Apache server on the day before the code jam, problem with static files. Though made sure I was able to run Django hello world on apache the 
prev weekend, this static file issue was unexpected. So, had to revert back to django server for demo purpose.
Conflict with the team:
Andrea - Designer No coding exp:
Wanted to do something that cannot be accomplished in 3 days. Made her understand that from a development stand point, this cannot be done

Add your idea of determining business for advisers through demographics for_advisors in resume. 
Other Coding websites: 
https://medium.com/coderbyte/the-10-best-coding-challenge-websites-for-2018-12b57645b654

Job site and leetcode replica: https://www.swecareers.com/company-profiles

Leetcode expl: - Kevin Naughton Jr - Nick White - Back to back swe

Interview Prep https://www.youtube.com/watch?v = lDTKnzrX6qU

All google tech roles https://www.youtube.com/watch?v = XEhZFtq0xTk

Google resume writing tips: https://youtu.be/zHcCaBfsc2s

Why nosql for big data? 
https://analyticsindiamag.com/nosql-vs-sql-database-type-better-big-data-applications/
nosql has no schema requirements: Say tomorrow you insert a webpag
e into your table and it does not have meta tags, but you have a restriction that it has 
to be present(You did not set null = True) Your insert will fail.To resolve this what sho
uld you do? set null = True for that col and_ do migrations.This is_ just an example

Distribute data storage and distributed query execution are a problem(yet possib) 
https://blog.yugabyte.com/what-is -distributed-sql/

When sql and nosql? 
Need acid(Bank database)-sql otherwise nosql(web crawler database, where data consistecy
is not the highest priority)

# ----------------------------------------------------------- General Interview Points block ---------------------------------------------------------------------------------------------------------

If you feel you are getting struck during the interview, try explaining how you reached that point of where you are getting struck and then ask the interviewer if your approach is correct or if thre is a
better approach. Ask for some possible inputs to this problem so you can see if your approach works. Basically you are aking for hints which is not wrong at all.

One trick you can use is.Tell the interviewer Theoritically I can see this should work.But the code might need some minor fixes and as_ I go through
the code and explain it to you, I can discover those hidden issues and fix them.Is that fine?

Always start thinking of how to solve the problem with a brute force approach. Explain to the interviewer and ask him if you can code that logic.
If you try to solve with an optimized approach you might not be able to solve the problem on time eg: Verifying an Alien Dictionary

Remember coding is only the LAST STEP. before you start writing code,
Thnik of an algorithm and run some extreme test cases on it in the paper or the computer screen before starting to write code. Or else, it could
turn out to be disastorous. Remember Paypal interview? Remeber Unival tree problem?
- Think out loud.Speak as_ you think because the interviewer will know your thought process.
NEED TO WALK THE INTERVIEWER THROUGH THE PROCESS

- Explain your algo before starting to write code so you may know if you need to tweak your algo
Get your algorithm precise and expalin it shortly to your interviewer before writing code
Implementing your algo should go as_smooth_as possible

Join the meeting atleast 5 mins before it starts.Nortonlifelock is an example. Ran out of time as_ I joined the call on time but due to technical difficulty, lost 6 mins and as_  a result was not able
to go to the second question
KEEP PHONE IN AIRPLANE MODE
Think about the corner cases.
Singly linked list median finding when only 1 node in list Handle them before your interviewer asks you to handle.
https://www.youtube.com/watch?v=7HgsS8bRvjo - Unival trees question, Remember how you missed the edge case?
When the given problem is not hard, the interviewer is going to be looking heavily at how careful you are. Did you check for error conditions?

Behavioral qustions for which we need correct answers? Have you ever had conflict and_if 
so, how did you handle it? Sophia example, 
https://www.youtube.com/watch?v=J49el9Fl8lM&t=680s 
sat down and weigh the pros and cons.If unable to solve, escalete to manager
 If you didnt meet a deadline, wht would you do?
See also the top of the file for answers

In design based questions, make use of api gateway( or) load balancer which distributes t
he load to different servers(n) based on the amount of cpu usage.Make use of n queues, th
e processes running on each of the server will pick the tasks from the respective
queues. We also need to learn about the task scheduling algorithms like round-robin, etc

Mock Kevin youtubers presentation of interview questions especially for recursion problems. Remembere muth mock interview coins prob
1 - Magic recursion function - then base case - then return value - then recursive calls - finally any logic needed inide recursion

Be sure to return your answer if you are using a func at the end of the func. Be sure to 
increment 'i' in while (i < len(something)) loops.

#Common questions to ask before coding for problems like
"Given a set of numbers(integers, values)", the first question to ask the interviewer is
"Does it include negative values and zero" as_well'?'
What should I return when there is no such combinations possible'?'
Will there be duplicates in the input'?'
Is the input sorted'?'
is there an interger max len I can assume for the input'?' If yes, it might help you in calc time compl. It would be benefitial in terms of theoritical
time complexities. Since you have a constant number of times your while loop will run, you can assume it as a constant when calc time
eg: https://leetcode.com/problems/verifying-an-alien-dictionary/
After discussing all clarification questions before starting the problem, Tell the interviewer, right now am clear in coming up with an algo
(or writing code). I will ask you any further clarification questions, if I encounter any while_ writing my algo (or code)
For any question, THINK (even for 2 mins if needed) before you give an answer. Its beeter to give correct ans after 2 mins than to give partial or
incorrect answer in 30 secs. Remeber mock with chen'?' the running sums dictionary where key 0 had to added. You did a good job there

Should use class during interviews. Makes implementation easier. Remember mock interview with chen. max_sum path.
Also remember you were planning to use log n at the leaf nodes where he was calc the sum of nodes in that branch which is wrong. It should be O(n) as
well because we are taking into account the worst case
Need to return the expected op from your function or atleast print the result at the end. Variable name and fun name should be meaningful

You might have to think of solving the probelm in a reverse order (or different way). eg: Throttling gateway problem. You were always thinking of
dropping the requests already in the queue which made it very complicated. rather you should have changes the way of thinking like you did lately

Try to avoid at all costs using dictionary or something else to solve topological sort re lated problems
https://aonecode.com/facebook-coding-interview-questions/Minimum-Time-to-Complete-Tasks

We can sometimes use set for solving a problem.Refer Maximum Length of a Concatenated String with Unique Characters.See link under runtime
set Union - s | t -> O(len(s) + len(t))
set intersection - s & t -> O(min(len(s), len(t))

Need to be more careful when reading a question.eg. 1239 leetcode.
The question asks "Maximum Length of a Concatenated String with_Unique Characters" and not "Maximum Length of a Concatenated CONTINUOS String with_Unique Characters"
another eg: Alien Dictionary https://leetcode.com/problems/alien-dictionary/. Only the words are ordered. the chars inside each word are not ordered

When handling questins like "Is subtree of another tree", we got to be a bit more careful when doing the solution by tree traversal algos and storing the values in a list and che
cking if child list is sublist of parent list.We need to store the none val of left and right child of leaf nodes in the list for correct results.

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# ------------------------------------------------------------------ Graph block  ------------------------------------------------------------------------------------------------------------------------
When doing bfs in undirected graph, queue a vertex only if it is not visited and set visited to true immediatly after QUEUING the vertex NOT after discoving the vertex. eg Clone Graph. Struggled a lot
because of not following  the above point. We do NOT worry if the graph has cycles in Clone Graph problem. But we have visited dictionary to make sure we do not go in an infinite loop

When doing recursion, list, dict and set objects maintain only one copy throughout the recursion proecess. So, if you want to have local copies or copy of an object specific to the recursion state. You should
remove (in case of set), pop(in case of dict), delete (in case of list) on the variable where you keep track of visited verices, once the recursive call for the node is over.
see  Course Schedule approach 2 - Recursion function

We can find cycles in DIRECTED graphs by using methods implemented in "Course Schedule"
- approach 1 (remembering active recursion state in the node object itself) or
- approach 2 (using recursion specific variables that hold visited nodes till that point in recursion)
- For both the above approaches, we need to make sure that we do not process a node more than once. If a cycle is there in the graph, lets say 4 nodes connected in a cycle. The first time we visit any one of
those 4 nodes, we will go into a cycle. Having the idea of previous line in mind, we can have global variable which holds the visited nodes and make sure that we do not process the same node more than once.
However, we need to cautious of 1 thing. We should set the node as discovered only at the end of the recusive function and not anywhere else. If we set it to discovered anywhere else, we will not be able to
find out cycles in graph.
eg checkout the "self.overall_discovered_nodes" variable in course schedule function and understand how its used and how it brings down the time complecity. "self.overall_discovered_nodes" does NOT HELP TO
FIND CYCLES.

Topological sort Algorithm can also be used to detect cycles in graph
L = Empty list that will contain the sorted elements
S = Set of all nodes with no incoming edge

while S is non-empty do
    remove a node n from S
    add n to tail of L
    for each node m with an edge e from n to m do
        remove edge e from the graph
        if m has no other incoming edges then
            insert m into S

if graph has edges then
    return error   (graph has at least one cycle)
else
    return L   (a topologically sorted order)

Time O(V + E)
Space O(V + E)

When we do a BFS we need to be extra careful (than dfs). Remeber Number of Islands question. You may  end up queueing the same (x,y) corordinate multiple times. You have 2 options
 - make sure that the same coordinate is not queued multiple times by keeping a hashmap of the entries that you queue - "in_queue = set()" in Number of Islands problem
 - Whenever you pop an element from the queue, before doing any other steps, make sure that the coordinate is not visited before
If you dont do one of the above you may get timelimit exceeded error

Union find algorithm is used to detect if there exists a cycle in an UNDIRECTED graph. Some example problems where we used Union find are as follows
1) Minimum-Spanning-Tree
2) Graph Valid Tree (In approach 2 we have used Union Find algo. In approach 1 we have used DFS to check for cycle. Its ENOUGH to do dfs from ONE of the nodes in an undirected graph anc check if we visit
a node more than once to detect cycles. Finally check if the seen dictionary is equal to the num of vertices). Whereas in directed graph we have to do DFS from every un-visited vertex
Union Find algo standalone will take O(n) time.
Union Find by Rank will take O(log n) time
Union Find Rank -> https://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/ eg: Number of Connected Components in an Undirected Graph, Notice the point where you increase rank


Some graph concepts:
Minimum Spanning Tree: In an undirected weighted graph, there is a tree (N nodes, N - 1 edges so no circle) that connects all nodes in the graph, and the sum of path weights are minimum.

For the graph to be a valid tree, it must have exactly n - 1 edges. Any less, and it can't' possibly be fully connected. Any more, and it has to contain cycles.
Additionally, if the graph is fully connected and contains exactly n - 1 edges, it can't' possibly contain a cycle, and therefore must be a tree. https://leetcode.com/problems/graph-valid-tree/solution/

Kruskal's' Algorithm: The approach to find the Minimum Spanning Tree in the Graph. We sort the edges by weight in non - descending order and loop sorted edges, pick the edge as long as
there are no connectivity already set up between two nodes and add this edge weight to the total weight.
https://leetcode.com/problems/connecting-cities-with-minimum-cost/discuss/344867/Java-Kruskal's-Minimum-Spanning-Tree-Algorithm-with-Union-Find

Disjoint Set: The data structure used to check the connectivity of graph efficiently in dynamic by union the nodes into one set, and find the number of disconnected sets.
geeksforgeeks.org/union-find/

# Additional notes
Dijkstra implementation done - we dont use min heaps because of certain constraints. You cannot pick a particular vertex or edge from the priority queue in O(1) time

# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# --------------------------------------------------- Binary or Bit manipulation block 0 and 1 ---------------------------------------------------------------------------------------------------------
Each integer is represented by 32 bits of 0 and 1
binary_representation = 2^31 2^30 .. 2^0 (notice that the 31st index is 2 ^ 31 and NOT 2^32)

Interview Tip for Bit Manipulation Problems: Use XOR

How to start'?' There is an interview tip for bit manipulation problems: if you dont know how to start, start from computing XOR for your input data. Strangely, that helps out for quite a lot of problems,
- https://leetcode.com/problems/sum-of-two-integers/

Remeber to add "=" after your shift operator. x >>= 1 or x <<= 1. If you miss out "=" and do x << 1, it will not update x
We can left shift by a certain number as well (ret = ret + (n & 1) << power) will left shift the least sig bit of n by power num of bits and add it to res. eg. 190 Reverse bitss

Bit shift operation: - right shift divides a num by 2 - left shift multiplies a num by 2 eg: https://leetcode.com/problems/divide-two-integers/

To find the duplicates in a list and missing elements refer You are given an array of integers. Return the smallest positive integer the... in python_test.py
XOR operations:
1 ^ 1 = 0
1 ^ 2 = 2 ^ 1
res = 7 ^ 3 ^ 5 ^ 4 ^ 5 ^ 3 ^ 4
print res  # prints 7 as all other eles occur EXACTLY twice
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0


x ^ x = 0,
x & 1 will give the least sig bit

# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# ------------------------------------------------------------------------------------------ Binary Search block ------------------------------------------------------------------------------------------

Regular binary search where you do (mid + 1) and (mid - 1) will work only when all that you need to do is finding the position of an elem in sorted array (or finding if an elem exists in sorted array).
The underly concept behind this is if you do (mid + 1 and mid - 1), you are assuming that mid_elem cannot be your ans. Eliminate mid by using (mid + 1 and mid - 1) only if you are cetain that mid is not
your ans. In the above mentioned problem (finding pos of ele in sorted arr) you will have "if nums[mid] == target:" which checks and eliminates the poss of mid being the ans
If your problem is to find
- Rightmost occurance of an elem in a sorted array (move i to the right  if nums[mid] == target: i = mid + 1)
- Leftmost occurance of an elem in a sorted array (move j to the left  if nums[mid] == target: j = mid - 1)
- Find the first element greater than the target in a sorted array
- Find minimum in a rotated sorted array
We need to modify the low = mid - 1 part or high = mid + 1 part depending on the question. Read below for more details

# approach 1 - Not recommended
def find_element(self, nums, target, pos):
    if not nums:
        return -1

    mid = len(nums) / 2
    if nums[mid] == target:
        return pos + mid  # print 'target found = ', target
    elif nums[mid] > target:
        return self.find_element(nums[0:mid], target, pos)
    else:
        return self.find_element(nums[mid + 1:], target, pos + mid + 1)

# approach 2 - Recommended when all that you need to do is finding the position of an elem in sorted array (or finding if an elem exists in sorted array)
binary search when using indices
def binary_search(st, en, search_num):
    if st > en:
        return False

    mid = (st + en) / 2
    row_num = mid / num_cols
    col_num = mid % num_cols

    if mat[row_num][col_num] == search_num:
        return True

    if mat[row_num][col_num] < search_num:
        # Important point ******mid + 1*******
        return binary_search(mid + 1, en, search_num)
    else:
        # Important point ******mid - 1*******
        return binary_search(st, mid - 1, search_num)

# approach 3 - HIGHLY Recommended when all that you need to do is finding the position of an elem in sorted array (or finding if an elem exists in sorted array)
We can also do binary search using while loop. Advantage of using while_ loop is the space complexity
while(lo < hi):
	mid = (low + high) // 2

	if mid == target:
		break
	elif mid < target:
		lo = mid + 1
	elif mid > target:
		hi = mid - 1

if you do not have "mid + 1" or "mid-1" and instead substitute just "mid", if the element is not there, in some edge cases it leads to inifinite loop. eg: seach a 2 d matrix This
 holds true only in the second approach, where you are only passing indices.When you are passing nums array itself as_ in approach 1 you have to do arr[st:mid] and arr[mid + 1:]

If they are asking you to solve a problem in log n time and you have to calculate the len of the array, you should explicitly tell the
interviewer that len(arr) takes O(n) time. Can I assume for this problem I will be given the array length so I dont have to calc it using len(arr)

binary search variation - find the left or right most index of a number in a sorted list
nums = [1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 7, 8, 9]
target = 3

def binary_search(st, en):
    if st > en:
        return st

    mid = (st + en) // 2
    mid_ele = nums[mid]

    if mid_ele < target:
        return binary_search(mid + 1, en)
    elif mid_ele > target:
        return binary_search(st, mid + 1)
    elif mid_ele == target:
        return binary_search(st, mid - 1) # To get the right most index, substitute by binary_search(mid + 1, en)
    else:
        return st

print(binary_search(0, len(nums) - 1))

biary search variation - in a sorted array find the first element greater than the target

running_sums_list = [3,17,18,25]
st = 0
en = len(running_sums_list) - 1
random_search_num = 3

while (st < en):
    mid = (st + en) // 2

    if running_sums_list[mid] == random_search_num:
        print(mid)
        st = mid
        break
    elif running_sums_list[mid] < random_search_num:
        st = mid + 1
    else:
        en = mid # Note this line, it's not mid - 1, it's just mid. In cases when mid element is the first elem greater than the target, this
        # logic comes in handy

print(st)

binary search variation - find minimum in a rotated sorted array
while (i < j):
    mid = (i + j) // 2

    if nums[mid] > nums[j]:
        i = mid + 1
    else:
        j = mid # this is just mid and NOT mid - 1. Your mid elem may be your ans. If you do mid - 1, you are skipping mid elem all together

Binary search can be modified in a number of ways and given as_ a question to you. You need to fig out how to manipulate the input in such
a way so that you can apply binary search directly on the input. This manipulatation should not done expilicitly as_ it will be O(n).
eg: https://leetcode.com/discuss/interview-question/723230/Google-or-Phone-or-Kth-missing-number
eg: https://leetcode.com/problems/missing-element-in-sorted-array/


# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# ------------------------------------------------------------------------------------ Dynamic Prog block ---------------------------------------------------------------------------------------

In recusion problems, If you are finding it hard to get started, write
def func_name(arg1, arg2,..):
	if base_condition:
		output_list.append(output)
		return

	# figure out your recursive call
    # figure out your return value

https://leetcode.com/problems/letter-combinations-of-a-phone-number/
https://leetcode.com/problems/generate-parentheses

Dynamic prog cheat tricks:

For questions asking you "Is it possible to .." our base case is similar to "num of ways you can" BUT here you will return True
 - Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. 139 word break
 - Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position.
   Determine if you are able to reach the last index. 55 Jump game

For question asking you the "num of ways you can"  we need to return 1 in the base case
 - You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top (70. Climbing stairs)
 - Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. (377 Combinations Sum IV)
 - Given a non-empty string containing only digits, determine the total number of ways to decode it. (91 Decode ways)
 - Robot in top left of matrix. How many ways can the robot reach bottom right corner 62 Unique Paths
 - num of ways you can add up to a given target using the given nums
 - num of ways a shopper can shop items given the costs of possibilities of each item and you are required to choose 1 possibility of each item. But you have only certain amount of money
 - Given a string S and a string T, count the number of distinct subsequences of S which equals T. (115 Distinct Subsequences)

For questions asking you whats the "max (or min) length or max (or min) value", we need to return 0 in the base case
 - Given an unsorted array of integers, find the length of longest increasing subsequence. (300. Longest Increasing Subsequence)
 - You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount.
   If that amount of money cannot be made up by any combination of the coins, return -1. (322 Coin Change)
 - Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.(213 House Robber II)
 - Min cost to consturct houses. Cannot paint adjacent houses with the same material.


See how modifying the input sligly for house robber problem solved the house robber II problem

For list comprehension, remember to add range() and len(). Its range(len(x)). [[False] * 2 for _ in range(len(nums))]

0 is equal to False. Remember House robber problem where we got struck with input [0,0,0,0]. if memo... was not getting satisfied

Noticed something wierd. Using tuples as keys in dictionary is faster than using 2-d array. eg 115 Distinct Subsequences. If we start using tuples, we will not be able to calc the time compl using
approach 1 discusses below

For memoized recursive solution, your time and space complexity is (95 % certain) the prod of dimensions of your memo matrix. Time complexity will
change if you have any loops within your recursive function eg. 55. Jump Game.
One other way to judge time compl is by looking at the paramenters you pass to the recursive function (by this way we need to make sure that we pass only the absolutely necessary parameters). Once you fig
out that, your time will most probably be,
time =  num_of_poss for x1 * num_of_poss for x2 * ..num_of_poss for xn * time taken for statements inside your recursive func (where x1 and x2 are the arguments to the recursive function)

The resoning behind this is, for a particular combination of x1, x2, .. xn, our recursive func will be executed only once. As we are memoizing the results for this particular combination of inp arguments,
wedo not process the recursive function's' lines of code more than once

# Old Notes
To understand, How many ways can you add up to a target usinf x, y and z. In how many ways ca you climb stairs, look at "Decode Ways" problem and 91_lc.jpg to undestand how the sol to these problems work

In Dyn Prog problems like how many ways can you add to N with_ 1, 3, 5 we have to define the base cases properly to get the proper result. This is a bottom up approach
eg: Number of ways to count to N with 1, 3, 5

dp = {}
dp[0] = dp[1] = dp[2] = 1  # 2 = 1 + 1
dp[3] = 2  # 1+1+1 or 3+0
dp[4] = 2  # 1+1+1+1 or 3+1
dp[5] = 3  # 1+1+1+1+1 or 3+1+1 or 5+0
n = 10
i = 6  # We have to make sure that all numbers from and after 6 can be substituted
# in the formula dp[i] = dp[i - 5] + dp[i - 3] + dp[i -1]

while (i < n):
    dp[i] = dp[i - 5] + dp[i - 3] + dp[i - 1]
    print     'i = ', i
    print     'dp = ', dp[i]
    i += 1

The above sol is a bottom-up approach
- When you have keywords like "minimize" and_ stuff, its a good indication that you can do it with_ dynamic programming. eg: https://leetcode.com/problems/minimum-path-sum /

For dynamic programming(memoization), calculating run time should be done line in pg133 of CTCI.For Recursion run time calc, follow pg132 of CTCI.

Returning at the end of the function(especially when you are doing recursion) is very important. eg: filter binary tree and Given a list of possible coins in cents, and an amount


DP cannot be used when you have keywords like Continuous in your problem statement You cannot use Dynamic programming for_ probs when the problem asks for_ a continuious subarray
within an array like - You are given an array of integers.Find the maximum sum of all possible continuious subarrays of the array

# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------





# ------------------------------------------------------------------ Backtracking block -----------------------------------------------------------------------------------------------------------------------

In backtracking problems, you could use a visited list to mark an index as visited (True) before your recursion starts and then change it False once that recursion is over. eg: 526 Beautiful Arrangement,
Efficient Janitor

# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# ------------------------------------------------------------------ array block -----------------------------------------------------------------------------------------------------------------------
In array grouping problems (even nums should appear first (or) Elements smaller than a value should appear first, etc.) Follow the following appprach. DO NOT COMPLICATE YOUR APPRACH LIKE IN approach 2 of
# Practice problem - keep odd first, even next in integer array

i = j = 0

while(j < len(arr)):
    if arr[j] % 2 != 1: # this line will be your condition
        arr[i], arr[j] = arr[j], arr[i]
        i += 1
        j += 1
    else:
        j += 1

print(arr)

In 3-ptr approaches, we need to figure out which ptr should be fixed and which ptrs should move around and how you should move them. eg. 3 sum problem (i is fixed ptr. j and k are moving pts)

when using 2 pointers, one important thing is we need to figure out if the 2 pointers moive in the
 - same direction (eg. rearrange around pivot in quick sort) Mostly i and j start at 0 in this case(or)
 - opposite direction (eg. Container with most water, 3 sum) Mostly i starts from 0 and j starts from end

In string problems, you can use an array[0 for i in range(26)] to represent characters and consider any opearation on this as O(1). Try to exploit the fact that there are only 26 alphabets.

When using Quick select, k should be the index of the array you want to find. You can also randomize selection of pivot which in practice will give a better run time. eg: Kth Largest Element in an Array.
Need to be careful when using quicksort. How to buid the array On which should you use quick sort. eg. Top K Frequent Elements. If 2 different elems have the same freq, the array on which you will do
quick select on should have 2 occurances of that frequency. eg: [4,1,-1,2,-1,2,3]. Here (-1 and 2) appears 2 times whereaas 4,1,3 appears 3 times. So, the freq_array on which you will do quickselect
should be [1,1,1,2,2]

Refer EPI 5.5. Easiest way - O(n) Remove duplicates from sorted array

a = [1,2,3]
b = a # shallow copy
b[0] = 2
print(a) # prints [2,2,3]

a = [1,2,3]
c = list(a)
c[0] = 2
print(a) # prints [1,2,3]
# NEED TO USE THE ABOVE LOGIC A LOT IN MATRIX PROBLEMS. REMEMBER AKUNA INTERVIEW matrix problem?

A[k:] + A[:k] # Rotates A by k to the left

------ Modified the sol to the foll problem to make life easier (Oct 4 2020) ---- follow the new sol. Making just 2 or few recursive calls is a possible way to solve the problem when the problem says you
can make only one change or 2 changes. eg. "Return whether or not it is possible to make the array non-decreasing by modifying..."

There are problems where you have to populate your result array from the endeg: https://leetcode.com/problems/merge-sorted-array If populating from the front doesnt work, populate from end.
Not clearhow to decide which probs require populating from rear.If you think of a solid solution before starting your answer, you will know if you should start from_ front or rear

# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# ------------------------------------------------------------------------------------------ Continuous array block ------------------------------------------------------------------------------------------
Continuous subarray problem approaches
- 2 ptr
- running sums
- store and modify max and min in each iteration of loop

If continuous subarray problems, when you use 2 pointers, you have to be carful about your inner while loop (condition) eg. Minimum Size Subarray Sum

The max number of continuous sub arrays that can be formed between 2 indices j and i is equal to j - i + 1. eg. Subarray Product Less Than K

New approach to solve problems. Keep max and min computed values in each iteration of loop and use that to calc your ans. eg. Maximum Product Subarray

How can you pick a random number from a given inp list where the prob of picking an elem is propotional to the value of item in list. Try to
understand in your mind how it works
https://leetcode.com/problems/random-pick-with-weight/

# If you are getting confused with logic behing running sums when implementing in interview. Think of the following simple ex
nums = [2,3]
k = 5
Think of running sums approach as_ one of the approaches to solving a prob You are given an array of integers. eg: You are given an array of integers, and an integer K.Return the
subarray. One important thing in runnong sums approach is to have key {0:1} in your dictionary. Remember mock interview with chen (facebook qus)

- The idea behind this approach is as follows: If the cumulative sum(repreesnted by sum[i] for sum upto i th index) upto two indices is the
 same, the sum of the elements lying in between those indices is zero. Extending the same thought further, if the cumulative sum upto two indices,
 say i and j is at a difference of k i.e. if sum[i] - sum[j] = k, the sum of elements lying between indices i and j is k.
eg: 560. Subarray Sum Equals K

# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# ------------------------------------------------------------------------------------------ Heaps block ------------------------------------------------------------------------------------------

maxheaps do not exisit. If you want to use max heap, multiply the values by -1 and do heappop().
- One issue with the above max heap approach is that it wont work properly on strings. Because '-item1' is still less than  '-item2'. Refer the below
link on how to implement this.
https://towardsdatascience.com/introduction-to-python-heapq-module-53534feda625?gi=928077f44b3


Heaps
import heapq
'''
THIS IS WRONG 
li = heapq.heapify([1,2,3])
print(li) will not print anything as its none
'''
li = [5, 7, 9, 1, 3]
heapq.heapify(li)

heapq.heappush(li, 4)

print(heapq.heappop(li))

Min and Max
heap:
>> > import heapq
>> > listForTree = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
>> > heapq.heapify(listForTree)  # for a min heap
heapq.heappop(listForTree)  # prints 1
>>> heapq._heapify_max(listForTree)  # max heap
heapq.heappop(listForTree)  # prints 15

- heap push and heap pop are(log n) operations.For building a heap, the O(n) = n  https://www.geeksforgeeks.org/time-complexity-of-building-a-heap /

- Heaps do not store values in ascending order. Rather heappop() outputs the elemets in ascending order.The order of elements in a list which has been heapifies is not ascending

# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# ------------------------------------------------------------------------------------ trees block ---------------------------------------------------------------------------------------

A rule of thumb that might work for most tree problems is to start thinking of a solution with 3 nodes in the tree and trying diff configurations with it. eg: Coin change (Muthu mock)

Be little more careful when you calc space compl. You must take recursion stack into account. So for most tree traversals is O(n)

Try to pass only the root object to recursive function in tree based problem. eg Invert Binary Tree, we tried passing left and right child to the helper and it didn't' workout very well

Another example of where we applied "general structure of tree" discussed below is in Binary Tree Maximum Path Sum. See how max_return_value and curr_max are different

# General structure of tree based qus
class FindLCA():
    def __init__(self):
        # Global variables
        self.node_1 = None
        self.node_2 = None
        self.lca = None

    # Main function which is going to return what we need
    def get_lca(self, root, node_1, node_2):
        self.node_1 = node_1
        self.node_2 = node_2
        self.find_lca(root)
        return self.lca

    # helper function or recursion function
    def find_lca(self, root):
        # base case
        if not root:
            return None

        # --------------------------------------------------------------------------------
        # Recursion block
        node_1_found_left, node_2_found_left = self.find_lca(root.left)
        node_1_found_right, node_2_found_right = self.find_lca(root.right)
        # --------------------------------------------------------------------------------

        # --------------------------------------------------------------------------------
        # Functionality block (where we populate the global variables based on the return values we got from recursive calls above)
        if root.val == self.node_1:
            if node_2_found_left or node_2_found_right:
                self.lca = root
                return True, True
            else:
                return True, node_2_found_left or node_2_found_right # True, False

        if root.val == self.node_2:
            if node_1_found_left or node_1_found_right:
                self.lca = root
                return True, True
            else:
                return node_1_found_left or node_1_found_right, True # False, True

        if (not self.lca) and (node_1_found_left or node_1_found_right) and (node_2_found_left or node_2_found_right):
            self.lca = root

        # --------------------------------------------------------------------------------

        # --------------------------------------------------------------------------------
        # Return block
        return node_1_found_left or node_1_found_right, node_2_found_left or node_2_found_right
        # --------------------------------------------------------------------------------

# Finally create class object and call the function
f = FindLCA()
lca = f.get_lca(root, l2.val, r2.val)
print(lca.val)

An example where a recursice solution can be converted to an iterative solution. "Given a sorted array, convert it into a binary search tree."
building a trie cannot be done using recursion.You have to use while and for_ loop comb eg: shortest unique prefix

Sometimes you have to change the postion of left and right for binary tree args in problems like this in recursive calls
update_output(node.left, row + 1, left, mid-1)
update_output(node.right, row + 1, mid + 1, right)
# Question: Print binary tree in a particular order

- In tree problems your first priority of approach should be DFS or BFS.If you can not think of a viable sol with dfs or bfs, go for_ inorder, preorder or postorder

In tree problems,
>>> root = Node(1)
>>> root.left = Node(2)
>>> root.left.left = Node(4)
>>> new_node = root.left.left
>>> new_node.data
4
>>> node = root.left
>>> node.data
2
>>> node = new_node
>>> node.data
4
>>> root.left.data  # root.left still points to the old val(2) and not new val(4)
2
# root.left still points
to the old val(2) and not new val(4) 2 If you do not explicitly change the(left or right) pointer of root( or node) to the new_node, the root( or node) will still be pointing to
the old node So, you have to do this
>>> root.left = new_node
application of this concept is in python_test.py in the foll problem "Given a binary tree, remove the nodes in which there is only 1 child"

Graph/tree concepts:
1. For problems in which the operations we do on a tree are related to levels (i.e.horizontal levels) of the tree or finding if there is an edge bet 2 nodes, use BFS approach
2. For problems related to vertical levels(height) of tree try using dfs
3. you can mostly solve any graph or tree problem using the following concepts:
3.1.Recursion
3.2.Dictionary
3.3.BINARY Tree traversal algos-Inorder, preorder and post order-These traversals work only for binary trees.For other type of trees, you should  use BFS_or DFS
3.4.Queue
3.5.Stack

For some of the problems like 4.6( in -order successor) in CTCI, We need to come up with  a pseudocode or small rules when trying to come up with a solution

# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# ------------------------------------------------------------------ Matrix block ----------------------------------------------------------------------------------------------------------------------

When doing a bfs of dfs in matrix problems, NEED to keep track of VISTED verices to avoid infinite recursion. When we move only in 2 directions (right and down), we will process a vertex more than once.
But in cases where we move in 4 directions, we will end up in infinite recursion if we do not keep track of visited verices

For some problems, we need to perform 2 bfs or 2 dfs to reach the solution. eg. 417 Pacific Atlantic Water Flow. We also needed 2 auxillary matrices to get verices which can reach pacific and atlantc.
Finally we did an intersection on them to arrive at result.

If you want to travel directions in matrix based problems, use something like this
directions =[(0, 1), (1, 0), (0, -1), (-1, 0)]

Not everytime in a matrix related problem, we can use BFS. Sometimes BFS might not be suitable.
eg: https://leetcode.com/problems/longest-line-of-consecutive-one-in-matrix/

In Matrix related problems, a wierd thing happens, check the transpose problem when we assign
tran_mat[i][j] = mat[i][j] it becomes[[1, None], [1, None], [1, None]] which is wrong it should have become[[1, None], [None, None], [None, None]] which is correct This prob
lem happens because of internal memory allocation reasons https://stackoverflow.com/questions/240178/list-of-lists-changes-reflected-across-sublists-unexpectedly

# The above happended because we are taking a shallow copy shallow copy when you created the tran_mat. You should create a mtrix like below

** ** ** ** ** Solution for the above prob ** ** ** ** ** ** ** **
mat = [[False] * len_row_col for _ in range(len_row_col)]

For matrix problems, In order to get "n'th" cell in a matrix. cell = mat[n/num_cols][n % num_cols] [0, 1, 2] [3, 4, 5] [6, 7, 8]
- You can apply the above formula in sudoku validator and search 2 d matrix and also search a flat 2 d matrix

# Old points
One important thing in matrix problems is:
1-Dont bother about the values in the matrix
2-Draw your matrix in your note and then see how row and col numbers change according to the question 00 01 10 11


# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# ------------------------------------------------------------------ Linkedlist block -----------------------------------------------------------------------------------------------------------------

Use fast ptr slow ptr approach to find loops in linked lists and problems like the below.
https://medium.com/@k1ckap0l03/rabbit-and-turtle-algorithm-2c68dde598a2
time compl is O(n)
https://www.youtube.com/watch?v=VX2oZkDJeGA

New idea for problem solving Having dummy nodes in linked list related problem to easily
solve the problem. eg: 83: Remove Duplicates from Sorted List

In linked list problems try not to have more than 2 pointers to nodes in your code eg: Swap Every Two Nodes in a Linked List First i planned on having fwd_ptr = node.next.next.next
The above approach would have made my while loop more complicated Later I came up with an approach to just settle for_ one node and it has worked fine.

# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# ------------------------------------------------------------------ Time and space comp block ---------------------------------------------------------------------------------------------------------

The time complexity is the length of your output because at the end of each recursion, we add the current output to the main output. Therefore we have had that many recursions that have happend.
The space complexity will be the depth of the recursion tree. eg 526 Beautiful Arrangement


Got a bit confused with the time compl calc of https://leetcode.com/discuss/interview-question/849799/Any-ideas-on-how-to-solve-this-Roblox-OA. Recursive call will happen only k * n times but in each
recursive call, we iterate through m possibilities. so its O(k * n * m)

checkout the timecompl of Merge k Sorted Lists. avg case O(N log k); worst case O(N log N)

In problems where you time compl goes up to 2 ^ n, the recursion depth will mostly be n. For ex in Split the given string into Primes, the depth of the recursion tree can
at max be length of the longest subsset, which atmost can be n

To understand time complexities of problems like
https://leetcode.com/problems/word-break/solution/
https://leetcode.com/problems/concatenated-words/discuss/159348/Python-DFS-readable-solution
See, how prof. Kasturi taught us on Feb 03 (refer photos in phone) to understand how the inefficient solution time complexity is calc. Prof says
its 2 ** n but the word-break sol says its n ** n. Personally I would go with n ** n as well. If you happen to solve a problem like this, tell the
interviewer that the inefficient solution time is n ** n and memoized sol time is n ** 2 (or) n ** 3 based on the problem

time complexity can sometimes be sqrt(n) as well.
eg: Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself. Its not n and its not log n

If you are using standard algos like BFS or DFS, the time complexity of the place in the problem where you are making
use of BFS or DFS wont change. eg: https://leetcode.com/discuss/interview-question/736717/Google-or-Phone-or-Start-to-End-with-Safe-states

Space complexity can go exponential
https://leetcode.com/discuss/interview-question/707842/Google-or-Phone-or-Time-to-reach-message-to-all-the-employees


When calculating time complexities be cautious when you have to have a '+' sign in between.
eg: https://techdevguide.withgoogle.com/paths/foundational/find-longest-word-in-dictionary-that-subsequence-of-given-string#code-challenge
eg: O(n + m)
https://leetcode.com/problems/implement-strstr/solution/
#See time comp of linear time approach
#time: O(n - k) * k

For Recursion problems, if you find difficulty in finding time compl.quickly draw a recursion tree and try to derive a relationship between the number of non Leaf nodes and the i
nput size and upper bound it eg: https://leetcode.com/problems/decode-ways/

Time complexities hierarchy: https://www.geeksforgeeks.org/analysis-algorithms-big-o-analysis/
one problem where I struggled to find time complexity
https://aonecode.com/google-coding-interview-questions/Word-Break-Combinations

Lists or arrays
pop() is O(1), but pop(index) is O(n)(since the whole rest of the list has to be shifted).
https://wiki.python.org/moin/TimeComplexity
Except push, pop, get, set and len, all list operations are non constant(i.e not O(1))
If you have the possibility to use try catch instead of checking for the len of list, you should use it. time comes down from o(n) to O(1)
If you slice a list like
l[0:i] + l[i + 1:], its O(h) + O(k), where h and k are len of the slices.But s + k = n-1. So we have to consider this slice_as O(n).
dict.keys() in python 2 is O(n), in python 3, its O(1). In python3, you can access the keys ONLY by list(dict.keys()). This is again O(n)

Time complexity of binary tree traversals(inor, preor, postor) or using dfs to traverse a binary tree is O(n) and the space complexity is O(n) because at a given time you will store
only O(max_height) calls in stack for recursion purpose and_ if_ the tree is left sided tree, we will sore n recursive calls in the stack. BFS also has O(n) time and space compl

Graph Time and space:
Undirected graphs and directed graphs: dfs time: O(V + E)
-You visit all vertices and edges exactly once
dfs sapce: O(V) In your recursion stack
Lets say we have 5 vertices and each of those vertices are connected to every other vertex We will have n vertices and n-1 edges going out of each of those vertices.
Since we represent the neighbors of a vertex in adjacency list( or matrix),  we need to allocate space for edges as_well.So, it will be n ^ 2 space for_ this prob
https://aonecode.com/facebook-coding-interview-questions/Minimum-Time-to-Complete-Tasks


- Binary search time complexity = O(log n) # you are searching in a list
- Searching in BST: time_comlexity(worst case) = O(n)
 # you are searching in a tree avg and best case-(log n)
https://www.geeksforgeeks.org/complexity-different-operations-binary-tree-binary-search-tree-avl-tree/
- Deletion from BST: time_complexity = O(n)
https://www.geeksforgeeks.org/binary-search-tree-set-2-delete /
- Bottomup approaches in trees can be done ONLY by DFS(cannot be done with_ bfs)  eg: https://www.youtube.com/watch?v=aaSFzFfOQ0o
- Top down approaches can also be implemented using DFS. Eg: Return true if it is a valid binary search tree

# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# ------------------------------------------------------------------------------------ Python specfics block --------------------------------------------------------------------------------------

intervals = sorted(intervals, key=itemgetter(1)) # sort list of tuples by 2nd element # method 1 works on the latest version of python
data.sort(key=lambda x: x[1]) # sort list of tuples by 2nd element # method 2 works on all versions of python
If we use sorted function and assign the result to the same variable, we are not using additional space. my_list = sorted(my_list) # space O(1)

Need to use while loop if possible than for loop (expecially when the problem involves range. eg: for i in range(min, max)). ALWAYS FORGETTING TO PUT MAX + 1. Roblox Surplus metal OA and amazon OA

read input from stdin
import sys

for line in sys.stdin:
    if 'q' == line.rstrip():
        break
    print(f'Input : {line}')

0 == False # will print True
0 == None # will print False
got struck with the above confusion in this prob https://leetcode.com/discuss/interview-question/849752/Roblox-SWE-Intern-OA-(Summer-2021)

When using heaps, if you are trying to insert a tuple in a heap like this heapq.heappush(q, (l.val, l)) where l is a Node object, the problem arises when there is a tie in both (l.val, l). Python does not
know how to insert into heap when you try to insert
heapq.heappush(q, (1, Node(2)))
heapq.heappush(q, (1, Node(2)))

because Node is a datatype defined by us and python is not able to resolve conflict when there is a tie and throws an error. To avoid this error, do the following.
heapq.heappush(q, (1, id(Node), Node(2)))
id() of two nodes will never be the same. eg. Merge k Sorted Lists

# Creating dict from iterable
d = {key: value for (key, value) in iterable}

# nonlocal kweyword
def myfunc1():
  x = "John"
  def myfunc2():
    nonlocal x
    x = "hello"
  myfunc2()
  return x

print(myfunc1())

Since loads and dumps are O(n) operation, we need to use it sparingly. https://leetcode.com/problems/serialize-and-deserialize-binary-tree/submissions/ . Look at the Oct 1 submissions. In the 1st submission
we got a timeout because we tried dumps and loads in every recursive call. In the 2nd submission, moved the loads and dumps outside the recursion and subumission went through.
In the submission that you did on Aug 13, we tried to form the serialized string ourself which is not the best idea. When we have json dumps inbuilt fun, need to use it

json.loads() requires the keys in the string to be enclosed within "". Single quotes '' wont work
https://stackoverflow.com/questions/39491420/python-jsonexpecting-property-name-enclosed-in-double-quotes
In order to support None datatype in json.loads(), you string should have 'null' value in it.
eg: https://leetcode.com/problems/serialize-and-deserialize-binary-tree/

Python default dictionary
from collections import defaultdict
food_count = defaultdict(int) # default value of int is 0
for food in food_list:
    food_count[food] += 1 # increment element's value by 1

city_list = [('TX','Austin'), ('TX','Houston'), ('NY','Albany'), ('NY', 'Syracuse'), ('NY', 'Buffalo'), ('NY', 'Rochester'),
('TX', 'Dallas'), ('CA','Sacramento'), ('CA', 'Palo Alto'), ('GA', 'Atlanta')]

cities_by_state = defaultdict(list)
for state, city in city_list:
    cities_by_state[state].append(city)

Passing dictionary object to a function and modifying it in the function modifies the orig dictionary
Lists and Dicts are mutable objects. Numbers, Strings, and Tuples are not.
You are passing the dictionary to the function, not a copy. Thus when you modify it, you are also modifying the original copy.
To avoid this, you should first copy the dictionary before calling the function, or from within the function (passing the dictionary to the dict
function should do it).

How to append columns dynamically in a 2d array?
https://leetcode.com/problems/zigzag-conversion/
l = [[]] * num_rows
l[0].append('P')
l[1].append('A')
l[2].append('Y')

divmod(5,2) #prints 2,1 (Quotient, remainder)
https://leetcode.com/problems/integer-to-roman

adding elems to a set directly can be done by
s = set()
s.add(5)
s.remove(5)
printing elems of a set: for item in s: print s

Python pointer- id(variable_name) gives the memory location of this variable.Needed this in the problem "Find cycles in tree"

Dont remove any elem from a list when iteration it with_ a for_ loop.
l = [1, 2, 3, 4]
for item in l:
    print(item)
    if item == 2: l.remove(2) # prints 1,2,4

dequeue - Double ended queue where insertion and deletion from_both ends can be done in O(1) time.

from_collections import_dequeue
d = dequeue()
d.extend([2, 3, 4, 5, 6])
d.appendleft(1)
d.popleft() # prints 1 In lists,
appendleft can be done like l =[1] + l # but this is (n) operation
eg of application.Sliding window maximum

Python appending an element does not create new memory.append happens in-place

Python prepending an element to array in -place arr.insert(0, 'value') See clockwise rotate of
'rotate the array by k spaces' problem.see methods 1 and 2

dictionary subsets
res = subset.items() <= superset.items() # method 1
res = all(superset.get(key, None) >= val for key, val in subset.items())
# method 2 Dictionary comparisions
 are tuple comparisions(key_1, val_1) > (key_2, val_2)

New concept: itertools itertools has lot of other libraries to find permutation, combinations, catesian_product and a lot more all_functions: https://docs.python.org/3/library/itertools.html

import itertools

tree = [1, 0, 1, 1, 4, 1, 4, 1, 2, 3]
for ele, v in itertools.groupby(tree):
    print 'ele = ', k
    print 'v = ', list(v)

ele = 1
v = [1]
ele = 0
v = [0]
ele = 1
v = [1, 1]
.....

>>> blocks = [(k, len(list(v)))
               for k, v in itertools.groupby(tree)]
>>> blocks
[(1, 1), (0, 1), (1, 2), (4, 1), (1, 1), (4, 1), (1, 1), (2, 1), (3, 1)]

python bisect module:  when you want to insert an element into a sorted array and still keep it sorted, make use of bisect module.This can be helpful for questions where you have a continuous input stream
of numbers.
eg: You are given a stream of numbers.Compute the median for each new element Python comes with a bisect module whose purpose is to find a position in list where an element needs to be inserted to
keep the list sorted.time comp to insert is log n as_ it uses binary search


import bisect

def insert(list, n):
    bisect.insort(list, n)
    return list

list = [1, 2, 4]
n = 3

print(insert(list, n))
Output:
[1, 2, 3, 4]

sum([True, False, True])  # Outputs 2

List difference is not possible but set difference is possible
>>> [1, 2, 3, 4]-[1, 2, 3] # is not possible TypeError: unsupported operand type(s)
#for-'list' and_ 'list'
>>> set([1, 2, 3, 4])-set([1, 2, 3]) set([4])


- list comprehension with_ if_ else_
'|'.join([ele if ele in ['X', 'O'] else '-' for ele in row])
# both if and else
'|'.join([ele for ele in row if ele in ['X', 'O']]) # only if

A = [1, 2, 1, 2, 4, 2, 2, 4]
Counter(A).most_common(3)
[(2, 4), (1, 2), (4, 2)]

How to write Class and objects

class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def test(self):
        print         'test called'


if __name__ == '__main__':
    p1 = Person("John", 36)
    print(p1.name)
    print(p1.age)
    p1.test()

if __name__ == '__main__': # what does this mean
https://stackoverflow.com/questions/419163/what-does-if -name-main-do


Zip for creating dict of 2 linked lists
https://realpython.com/python-zip-function

OrderedDict # Python 3 Stores the keys in the order we save them
from collections import OrderedDict

d = OrderedDict.fromkeys('abcde')
# can also be initialized as
# d = OrderedDict()
d.move_to_end('b') # O(1) operation IMPORTANT
d.keys()  # odict_keys(['a', 'c', 'd', 'e', 'b'])
list(d.keys())  # ['a', 'c', 'd', 'e', 'b']
d.move_to_end('b', last=False) # O(1) operation IMPORTANT
print ''.join(d.keys())  # 'bacde'
d.pop('key')  # remove a key from dict

d[b] = 1
d[a] = 2
d[c] = 5
print d[(list(d.keys())[2])]  # 2

Removing element from list

animal = ['cat', 'dog', 'rabbit', 'guinea pig', 'dog', 'dog']
animal.remove('rabbit')
print animal  # ['cat', 'dog', 'guinea pig', 'dog', 'dog']
animal.remove('dog')  # Removes only the 1st occurance of dog
print animal  # ['cat', 'guinea pig', 'dog', 'dog']
animal.pop(2)( or) del animal[2, 3]  # deletes element at index 2 time - O(n)
print animal  # ['cat', 'dog', 'dog']
del animal[2, 10]  # will remove element at index 2. This will not throw
# index error
print animal  # ['cat', 'dog']

# --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# -------------------------------------------------------------------------------------- Stacks Block ----------------------------------------------------------------------------------------------

In most stack based problem, we can follow a standard approach

for ele in array:
    while(stack[-1] condition curr_elem):
        ele_2 = stack.pop()
        # Do some calc
    stack.append(ele)

New technique to solve problem:
Use stack with the following prop.

- You cannot place a bigger element on top of a smaller element.This statement is not valid.In histogram you cannot place small elem on top of a bigger element.

- In some cases( or may be most cases) you will store indices in the stack instead of the element itself.
 For ex: In Trapping Rain Water, LC problem, We need to know how far the verticals walls (or bars) are apart.This is the breadth of the rectangle and we need it calc the area.
 Ref-dia lc_stack_general.png

 - How to determine which of the following scenarios a problem can be solved in
 1-You cannot place a big ele on top of small ele
 2-You cannot place small ele on top of big ele

Draw the bar chart diagram in you notebook.
Think which one(small bar or big bar) you need in later parts to solve the problem.

For ex.in_ trapping rain water you want to keep the big bars(height 5) in your stack unti ll a bar bigger than that comes in. This implies that bars of height <= 5 can occur anywhere
after 5 in the stack. The thought process behind this reasoning is.Lets say we get bars of size 3 and 2 after 5. 5 will act as_ left boundary and water can still be stored on
top of 3 and 2. So, 5 can act as_ a left boundary for all bars whose height is_ less than 5. If we get a new_bar of size >= 5, 5 can never act as_ left boundary because now we m
ust have new_bar(ht >= 5) as_ the left boundary.

In another ex.Think of Largest Rectangle in Histogram problem. Contrasting to trapping rain water, here we need to keep the small bars(height 2) in your stack untill a bar smaller
than than comes in. This implies that bar of height >= 2 can occur anywhere after 2 in the stack. The thought behind this reasoning is same as_ above. 2 will act as_ a left boudary
for all bars that occur on the right hand side of it(which are >= 2).

In both these problems, we can notice one thing. - If a smaller bar in the bar chart can bound the larger bars, we need to keep the smaller bars in the stack as_ long as_ possible
That is till a bar smaller than that comes in.In that case, Largest Rectangle in Histogram


curr_ele = inp[curr_ind]
while (inp[stack[-1]] >= curr_ele):
    stack_top_index = stack.pop()
    height_stack_top_index = inp[stack_top_index]
    width = curr_ind - stack_top_index
    area = height_stack_top_index * width

- If a taller bar in the bar chart can bound the samller bars, we need to keep the taller
bars in the stack as_ long as_ possible.That is till a bar taller than that comes in.In
that case, trapping rain water

while (curr_ele >= inp[stack[-1]])

# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# -------------------------------------------------------------------------------------- Math Block -------------------------------------------------------------------------------------------

Number system conversions https://www.rapidtables.com/convert/number/hex-to-decimal.html

Math fact a composite number must have a factor less than the square root of that number.
Otherwise, the number is prime.So if you check for_ prime, #Refer also Perfect Number problem for a potential question in this topic
for i in range(2, math.sqrt(n) + 1):
Remember the range has a '+ 1' at the end in range. Amazon OA experiece. We forgot to add "+ 1" at the end and as a result many cases failed
Roblox interview again Cutting metal surplus

bitmasks are a foolproof way of soving certain types of problems, especially permutations
 eg: subsets-https://leetcode.com/problems/subsets /

Permuatation and combination https://www.mathsisfun.com/combinatorics/combinations-permutations.html

I find it easier to calculate the time complexity by logical reasoning rather than simply
 going with the below formula.

 eg: https://leetcode.com/problems/subsets/solution/

(see approach 2 on LC), Restore IP addresses. Note there is a difference between subsets(1 st problem above) and
 https://aonecode.com/google-coding-interview-questions/Word-Break-Combinations
because the order the each number occurs matter whereas in the word break combinations problem the words can occur in any order.Calculation run times of these 2 probs need
 to be done differently Try to understand how you came up with the time compl for_above probs.


For permutations, time complexity is nPr = n!/(n-r)!, The reason this is nPr we would hav
e made nCr recursive calls to have computed all the results space is same as_time because
, we need to store nPr number of values in result variable


For combination problems, time complexity is nCr = n!/r! *(n-r)! (We just multiply 1/r! t
o nPr to get nCr) space is same as_ time because you have to store nCr nnumber of values
in result variable https://leetcode.com/problems/combinations/solution


NP concept: for sorted pos int array eg arr =[1, 2, 3, 6, ...] say i = res = 6
If elements from 0 to(i-1) can represent 1 to res-1(which is 5), then elements from 0 to i can be added up to represent all numbers from 1 to res + arr[i]  1 which is 1 to 11
refer "Given a sorted list of positive numbers, find the smallest positive number that cannot be a sum of any subset in the list"

# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# ------------------------------------------------------------------ Interval block --------------------------------------------------------------------------------------------------------

Remember how Merge Intervals helped in Insert Interval problem

For some problems, you may have to sort the intervals based on the end value instead of the start value. eg 435 Non-overlapping Intervals. eg test case:[[2,8],[3,4],[4,5],[5,6]]

# ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# ------------------------------------------------------------------ Sliding Window block --------------------------------------------------------------------------------------------------------

You add elements to the window using the end pointer untill a condition is satisfied. Once the condition is satisfied, you remove elements pointed to by the start pointer

# General structure
st = en = 0

while(st < len(s))

    while(en < len(s) and some_conditions_to_ensure_window_requirement_not_reached):
        # Add elements to the window
        en += 1

    # remove elem from window
    st += 1

# ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# -------------------------------------------------------------------------------------- OOPS Block ----------------------------------------------------------------------------
Virtual functions:
https://www.geeksforgeeks.org/virtual-function-cpp/
https://docs.microsoft.com/en-us/cpp/cpp/virtual-functions?view=vs-2019
If you declare 2 functions of the same name in both base and derived class_.When you add virtual keyword before the function name in the base class_ then this function is a virtual function. A virtual
function is a member function that you expect to be redefined in derived classes. When you refer to a derived class_ object using a pointer or a reference to the base class_, you can call
a virtual function for that object and_ execute the derived class_'s' version of the function. When the virtual fun in base class_ or the function in the derived class_ has different
arguments, the purpose of virtual functions is lost.It becomes method overloading

Virtual destructors Deleting a derived class_object using a pointer to a base_class, that has a non-virtual destructor results in undefined behavior.To correct this situation, the
base_class should be defined_with a virtual destructor.
https://www.geeksforgeeks.org/virtual-destructor/

4 oop concepts-Inheritance, Polymorphism, encapsulation, Abstraction
https://medium.com/@shanikae/polymorphism-explained-simply-7294c8deeef7
Method overriding is dynamic Polymorphism Method overloading is static Polymorphism

Diff bet Abstraction and enacapsulation:
https://javarevisited.blogspot.com/2017/04/difference-between-abstraction-and-encapsulation-in-java-oop.html

In encapsulation the motive is to secure data by declaring it private. Bank account balance, b_a_b-should be updated only by transaction method. The variable b_a_b should be declared private so that no
other classes other than the current _class can update this variable. If a variable is declared as private, only the class methods can access and modify it.
https://www.guru99.com/java-oops-encapsulation.html

On the other hand Abstraction is_ hiding the underlying functionality as_ its not needed for the person who is_ using it.Eg-person using hashmap need not_ know the underlying implementaion of how its done
(using tree or graph or bst or stack).He needs to know to just how to use it and thats all.

Abstraction: Hiding undelying functionality of the class_ to make sure the person using the class_ doesnt get perplexed about the implementaion
https://stackify.com/oop-concept-abstraction/

enacapsulation Process of bundling all the methods and attributes exclsively specific to a class_. Sensitive(attributes and functions) should be declared in private and made accessible only the other
public methods of the same class_.
https://stackify.com/oop-concept-for-beginners-what-is-encapsulation/

Thread and Process example
Celery gives the benefit spawning multiple threads for a worker. So, we had different number of threads running simultaneously for each worker. Each worker will operate on multiple queues at the same time.

It they ask what is the benefit, you can say, threads share resources while processes do not. Threads are more economical than processes. eg: Lets we have only 2gb of ram and if a process is allotted all 2gb,
then any other process we want to execute has to wait for the currently running process to complete.

Whereas in case of threads, say we allotted the same 2gb of ram to a process, but we want several subtasks to execute simultaneously, we need not wait for the currently running process to end for these sub
tasks to start. These sub tasks can take place using threads originating from the parent process and all these will share the 2gb ram initially allotted to the parent process.

So which one is better? Well, the answer depends on the use case.
For a word processor, we need spell check, alignment and other formatting to work simultaneously as we are typing. So, threads are benefitial in this case.
For a brower, lets say chrome, each tab has a webpage. Any issue in the webpage displayed in tab 1 should not impact the webpage displayed on tab 2. So, we need seperate processes for each tab to keep
each browser tabs independent of the other.
In general, if we want two tasks to function independetly of one another, rather lets me put it this way, we have two tasks and we dont want failure of task 1 to have any impace on task 2, then we use process
Whereas, If a task has several subtasks, each of which has to happen simulateously for the task to successfully complete, we can opt for threads

https://medium.com/@yutafujii_59175/multi-thread-and-multi-process-5559ea5b19ba (See the list of resources all threads in a process share in this link)
https://techdifferences.com/difference-between-multiprocessing-and-multithreading.html
 Multiprocessing - Multiprocessing adds CPUs or processors to increase computing power.
 - Multiple processes are executed concurrently.
 - Creation of a process is time-consuming and resource intensive.
 - eg: Google chrome maintains a seperate process for each webpage opened. So, if there is a problem with one webpage, the other is not affected

Multithreading
- Multithreading creates multiple threads of a single process to increase computing power.
- Multiple threads of a single process are executed concurrently.
- Creation of a thread is economical in both sense time and resource.
- threads belonging to the same process has to share the belongings of that process like code, data, and system resources.
- eg: A word processor, displays graphic, responds to keystrokes, and at the same time, it continues spelling and grammar checking.You do not have to open different word
 processors to do this concurrently.It does get happen in a single word processor_with the help of multiple threads.

How to decide if we should opt for multi threading or multiprocessing
It depends on the kind of app we are building.
If two different modules of the app should work independently of each other (a malfunction in one module should not affect the other module), choose multiprocessing and vice versa


# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



Interactive problem Guess the word had new approach. Just keep it in mind
https://leetcode.com/problems/guess-the-word/discuss/133862/Random-Guess-and-Minimax-Guess-with-Comparison

Computational Geometry problem:"Given two rectangles, find the area of intersection."

In sliding window problems, think of solving the problem using a window like approach, shortening the window and expanding the window.Using dictionary could also be an approach
but sometimes it may get complicated eg: Minimum sliding window


- usually word search related problems are best when done using tries

Merge intervals-FB question https://leetcode.com/problems/merge-intervals / Do NOT ASSUME
 your intervals are sorted and do not ASSUME that the 0 th ele in a particular interval i
s smaller than the 1 st ele of the next interval. You cannot also assume that[[1, 4], [2,
 3]] wont exist.Though 2 is less than 4, you cannot assume that the 3 will be greater tha
n 4(coz its not)

Consider using 2 pointers in a single loop. 1 ptr might get incremented and the other mig
ht get decremented eg: https://leetcode.com/problems/3 sum-closest / https://leetcode.com
/problems/4 sum /

Sometimes the best possible sol to solve the problem could be to use nested loops eg: 
https://leetcode.com/problems/jump-game-ii /

When trying to memoize you need an n-dimensional array where n is the no of paramenters t
he recursive function absolutely needs. eg: smooth_shuffle needs 4-d array when you want 
to memoize your algo.
We need to be extremely careful when forming recursive calls. We should try to minimize the parameters to the input function as much as possible.
Otherwise we will end in an algorithm which will have a terrible run time
eg: approach 0 in this prob Given a list of integers, write a function that returns the largest sum of non-adjacent numbers. Numbers can be 0 ...


Greedy solutions: - Go through the input elems one at a time. - Make a decision on whethe
r you have to pick the element or not and move fwd - eg: Minimum Cost Tree From Leaf Values, Find the maximum sum of all possible contiguous...

- Try to make use of every single detail in the question.You can solve the problem easily and in a better way.There could be some hints at the end of the question like this one(compare strings)
https://leetcode.com/discuss/interview-question/352458 / See the python ans to understand how he has made use of the clue in the question


